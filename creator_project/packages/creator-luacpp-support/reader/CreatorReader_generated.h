// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CREATORREADER_CREATOR_BUFFERS_H_
#define FLATBUFFERS_GENERATED_CREATORREADER_CREATOR_BUFFERS_H_

#include "flatbuffers/flatbuffers.h"

namespace creator {
namespace buffers {

struct SceneGraph;

struct NodeTree;

struct SpriteFrame;

struct CreatorScene;

struct Node;

struct Sprite;

struct Label;

struct RichText;

struct Particle;

struct TileMap;

struct Scene;

struct Button;

struct ProgressBar;

struct ScrollView;

struct EditBox;

struct SpineSkeleton;

struct AnimationRef;

struct AnimationClip;

struct AnimCurveData;

struct AnimProps;

struct AnimEvents;

struct AnimPropRotation;

struct AnimPropPosition;

struct AnimPropPositionX;

struct AnimPropPositionY;

struct AnimPropScaleX;

struct AnimPropScaleY;

struct AnimPropWidth;

struct AnimPropHeight;

struct AnimPropColor;

struct AnimPropOpacity;

struct AnimPropAnchorX;

struct AnimPropAnchorY;

struct AnimPropSkewX;

struct AnimPropSkewY;

struct Vec2;

struct Vec3;

struct Size;

struct Rect;

struct ColorRGB;

struct ColorRGBA;

enum FontType {
  FontType_System = 0,
  FontType_BMFont = 1,
  FontType_TTF = 2,
  FontType_MIN = FontType_System,
  FontType_MAX = FontType_TTF
};

inline const char **EnumNamesFontType() {
  static const char *names[] = { "System", "BMFont", "TTF", nullptr };
  return names;
}

inline const char *EnumNameFontType(FontType e) { return EnumNamesFontType()[static_cast<int>(e)]; }

enum VerticalAlignment {
  VerticalAlignment_Top = 0,
  VerticalAlignment_Center = 1,
  VerticalAlignment_Bottom = 2,
  VerticalAlignment_MIN = VerticalAlignment_Top,
  VerticalAlignment_MAX = VerticalAlignment_Bottom
};

inline const char **EnumNamesVerticalAlignment() {
  static const char *names[] = { "Top", "Center", "Bottom", nullptr };
  return names;
}

inline const char *EnumNameVerticalAlignment(VerticalAlignment e) { return EnumNamesVerticalAlignment()[static_cast<int>(e)]; }

enum HorizontalAlignment {
  HorizontalAlignment_Left = 0,
  HorizontalAlignment_Center = 1,
  HorizontalAlignment_Right = 2,
  HorizontalAlignment_MIN = HorizontalAlignment_Left,
  HorizontalAlignment_MAX = HorizontalAlignment_Right
};

inline const char **EnumNamesHorizontalAlignment() {
  static const char *names[] = { "Left", "Center", "Right", nullptr };
  return names;
}

inline const char *EnumNameHorizontalAlignment(HorizontalAlignment e) { return EnumNamesHorizontalAlignment()[static_cast<int>(e)]; }

enum SpriteType {
  SpriteType_Simple = 0,
  SpriteType_Sliced = 1,
  SpriteType_Tiled = 2,
  SpriteType_Filled = 3,
  SpriteType_MIN = SpriteType_Simple,
  SpriteType_MAX = SpriteType_Filled
};

inline const char **EnumNamesSpriteType() {
  static const char *names[] = { "Simple", "Sliced", "Tiled", "Filled", nullptr };
  return names;
}

inline const char *EnumNameSpriteType(SpriteType e) { return EnumNamesSpriteType()[static_cast<int>(e)]; }

enum SpriteSizeMode {
  SpriteSizeMode_Custom = 0,
  SpriteSizeMode_Trimmed = 1,
  SpriteSizeMode_Raw = 2,
  SpriteSizeMode_MIN = SpriteSizeMode_Custom,
  SpriteSizeMode_MAX = SpriteSizeMode_Raw
};

inline const char **EnumNamesSpriteSizeMode() {
  static const char *names[] = { "Custom", "Trimmed", "Raw", nullptr };
  return names;
}

inline const char *EnumNameSpriteSizeMode(SpriteSizeMode e) { return EnumNamesSpriteSizeMode()[static_cast<int>(e)]; }

enum ScrollViewDirection {
  ScrollViewDirection_None = 0,
  ScrollViewDirection_Vertical = 1,
  ScrollViewDirection_Horizontal = 2,
  ScrollViewDirection_Both = 3,
  ScrollViewDirection_MIN = ScrollViewDirection_None,
  ScrollViewDirection_MAX = ScrollViewDirection_Both
};

inline const char **EnumNamesScrollViewDirection() {
  static const char *names[] = { "None", "Vertical", "Horizontal", "Both", nullptr };
  return names;
}

inline const char *EnumNameScrollViewDirection(ScrollViewDirection e) { return EnumNamesScrollViewDirection()[static_cast<int>(e)]; }

enum EditBoxReturnType {
  EditBoxReturnType_Default = 0,
  EditBoxReturnType_Done = 1,
  EditBoxReturnType_Send = 2,
  EditBoxReturnType_Search = 3,
  EditBoxReturnType_Go = 4,
  EditBoxReturnType_MIN = EditBoxReturnType_Default,
  EditBoxReturnType_MAX = EditBoxReturnType_Go
};

inline const char **EnumNamesEditBoxReturnType() {
  static const char *names[] = { "Default", "Done", "Send", "Search", "Go", nullptr };
  return names;
}

inline const char *EnumNameEditBoxReturnType(EditBoxReturnType e) { return EnumNamesEditBoxReturnType()[static_cast<int>(e)]; }

enum EditBoxInputFlag {
  EditBoxInputFlag_Password = 0,
  EditBoxInputFlag_Sensitive = 1,
  EditBoxInputFlag_InitialCapsWord = 2,
  EditBoxInputFlag_InitialCapsSentence = 3,
  EditBoxInputFlag_InitialCapsAllCharacters = 4,
  EditBoxInputFlag_LowercaseAllCharacters = 5,
  EditBoxInputFlag_MIN = EditBoxInputFlag_Password,
  EditBoxInputFlag_MAX = EditBoxInputFlag_LowercaseAllCharacters
};

inline const char **EnumNamesEditBoxInputFlag() {
  static const char *names[] = { "Password", "Sensitive", "InitialCapsWord", "InitialCapsSentence", "InitialCapsAllCharacters", "LowercaseAllCharacters", nullptr };
  return names;
}

inline const char *EnumNameEditBoxInputFlag(EditBoxInputFlag e) { return EnumNamesEditBoxInputFlag()[static_cast<int>(e)]; }

enum EditBoxInputMode {
  EditBoxInputMode_Any = 0,
  EditBoxInputMode_EmailAddress = 1,
  EditBoxInputMode_Numeric = 2,
  EditBoxInputMode_PhoneNumber = 3,
  EditBoxInputMode_URL = 4,
  EditBoxInputMode_Decime = 5,
  EditBoxInputMode_SingleLine = 6,
  EditBoxInputMode_MIN = EditBoxInputMode_Any,
  EditBoxInputMode_MAX = EditBoxInputMode_SingleLine
};

inline const char **EnumNamesEditBoxInputMode() {
  static const char *names[] = { "Any", "EmailAddress", "Numeric", "PhoneNumber", "URL", "Decime", "SingleLine", nullptr };
  return names;
}

inline const char *EnumNameEditBoxInputMode(EditBoxInputMode e) { return EnumNamesEditBoxInputMode()[static_cast<int>(e)]; }

enum LabelOverflowType {
  LabelOverflowType_None = 0,
  LabelOverflowType_Clamp = 1,
  LabelOverflowType_Shrink = 2,
  LabelOverflowType_ResizeHeight = 3,
  LabelOverflowType_MIN = LabelOverflowType_None,
  LabelOverflowType_MAX = LabelOverflowType_ResizeHeight
};

inline const char **EnumNamesLabelOverflowType() {
  static const char *names[] = { "None", "Clamp", "Shrink", "ResizeHeight", nullptr };
  return names;
}

inline const char *EnumNameLabelOverflowType(LabelOverflowType e) { return EnumNamesLabelOverflowType()[static_cast<int>(e)]; }

enum AnyNode {
  AnyNode_NONE = 0,
  AnyNode_Scene = 1,
  AnyNode_Sprite = 2,
  AnyNode_Label = 3,
  AnyNode_Particle = 4,
  AnyNode_TileMap = 5,
  AnyNode_Node = 6,
  AnyNode_Button = 7,
  AnyNode_ProgressBar = 8,
  AnyNode_ScrollView = 9,
  AnyNode_CreatorScene = 10,
  AnyNode_EditBox = 11,
  AnyNode_RichText = 12,
  AnyNode_SpineSkeleton = 13,
  AnyNode_MIN = AnyNode_NONE,
  AnyNode_MAX = AnyNode_SpineSkeleton
};

inline const char **EnumNamesAnyNode() {
  static const char *names[] = { "NONE", "Scene", "Sprite", "Label", "Particle", "TileMap", "Node", "Button", "ProgressBar", "ScrollView", "CreatorScene", "EditBox", "RichText", "SpineSkeleton", nullptr };
  return names;
}

inline const char *EnumNameAnyNode(AnyNode e) { return EnumNamesAnyNode()[static_cast<int>(e)]; }

template<typename T> struct AnyNodeTraits {
  static const AnyNode enum_value = AnyNode_NONE;
};

template<> struct AnyNodeTraits<Scene> {
  static const AnyNode enum_value = AnyNode_Scene;
};

template<> struct AnyNodeTraits<Sprite> {
  static const AnyNode enum_value = AnyNode_Sprite;
};

template<> struct AnyNodeTraits<Label> {
  static const AnyNode enum_value = AnyNode_Label;
};

template<> struct AnyNodeTraits<Particle> {
  static const AnyNode enum_value = AnyNode_Particle;
};

template<> struct AnyNodeTraits<TileMap> {
  static const AnyNode enum_value = AnyNode_TileMap;
};

template<> struct AnyNodeTraits<Node> {
  static const AnyNode enum_value = AnyNode_Node;
};

template<> struct AnyNodeTraits<Button> {
  static const AnyNode enum_value = AnyNode_Button;
};

template<> struct AnyNodeTraits<ProgressBar> {
  static const AnyNode enum_value = AnyNode_ProgressBar;
};

template<> struct AnyNodeTraits<ScrollView> {
  static const AnyNode enum_value = AnyNode_ScrollView;
};

template<> struct AnyNodeTraits<CreatorScene> {
  static const AnyNode enum_value = AnyNode_CreatorScene;
};

template<> struct AnyNodeTraits<EditBox> {
  static const AnyNode enum_value = AnyNode_EditBox;
};

template<> struct AnyNodeTraits<RichText> {
  static const AnyNode enum_value = AnyNode_RichText;
};

template<> struct AnyNodeTraits<SpineSkeleton> {
  static const AnyNode enum_value = AnyNode_SpineSkeleton;
};

inline bool VerifyAnyNode(flatbuffers::Verifier &verifier, const void *union_obj, AnyNode type);

enum AnimWrapMode {
  AnimWrapMode_Default = 0,
  AnimWrapMode_Normal = 1,
  AnimWrapMode_Loop = 2,
  AnimWrapMode_PingPong = 3,
  AnimWrapMode_Reverse = 4,
  AnimWrapMode_LoopReverse = 5,
  AnimWrapMode_PingPongReverse = 6,
  AnimWrapMode_MIN = AnimWrapMode_Default,
  AnimWrapMode_MAX = AnimWrapMode_PingPongReverse
};

inline const char **EnumNamesAnimWrapMode() {
  static const char *names[] = { "Default", "Normal", "Loop", "PingPong", "Reverse", "LoopReverse", "PingPongReverse", nullptr };
  return names;
}

inline const char *EnumNameAnimWrapMode(AnimWrapMode e) { return EnumNamesAnimWrapMode()[static_cast<int>(e)]; }

MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() { memset(this, 0, sizeof(Vec2)); }
  Vec2(const Vec2 &_o) { memcpy(this, &_o, sizeof(Vec2)); }
  Vec2(float _x, float _y)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
};
STRUCT_END(Vec2, 8);

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() { memset(this, 0, sizeof(Vec3)); }
  Vec3(const Vec3 &_o) { memcpy(this, &_o, sizeof(Vec3)); }
  Vec3(float _x, float _y, float _z)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), z_(flatbuffers::EndianScalar(_z)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(Vec3, 12);

MANUALLY_ALIGNED_STRUCT(4) Size FLATBUFFERS_FINAL_CLASS {
 private:
  float w_;
  float h_;

 public:
  Size() { memset(this, 0, sizeof(Size)); }
  Size(const Size &_o) { memcpy(this, &_o, sizeof(Size)); }
  Size(float _w, float _h)
    : w_(flatbuffers::EndianScalar(_w)), h_(flatbuffers::EndianScalar(_h)) { }

  float w() const { return flatbuffers::EndianScalar(w_); }
  float h() const { return flatbuffers::EndianScalar(h_); }
};
STRUCT_END(Size, 8);

MANUALLY_ALIGNED_STRUCT(4) Rect FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float w_;
  float h_;

 public:
  Rect() { memset(this, 0, sizeof(Rect)); }
  Rect(const Rect &_o) { memcpy(this, &_o, sizeof(Rect)); }
  Rect(float _x, float _y, float _w, float _h)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), w_(flatbuffers::EndianScalar(_w)), h_(flatbuffers::EndianScalar(_h)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float w() const { return flatbuffers::EndianScalar(w_); }
  float h() const { return flatbuffers::EndianScalar(h_); }
};
STRUCT_END(Rect, 16);

MANUALLY_ALIGNED_STRUCT(1) ColorRGB FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;

 public:
  ColorRGB() { memset(this, 0, sizeof(ColorRGB)); }
  ColorRGB(const ColorRGB &_o) { memcpy(this, &_o, sizeof(ColorRGB)); }
  ColorRGB(uint8_t _r, uint8_t _g, uint8_t _b)
    : r_(flatbuffers::EndianScalar(_r)), g_(flatbuffers::EndianScalar(_g)), b_(flatbuffers::EndianScalar(_b)) { }

  uint8_t r() const { return flatbuffers::EndianScalar(r_); }
  uint8_t g() const { return flatbuffers::EndianScalar(g_); }
  uint8_t b() const { return flatbuffers::EndianScalar(b_); }
};
STRUCT_END(ColorRGB, 3);

MANUALLY_ALIGNED_STRUCT(1) ColorRGBA FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;
  uint8_t a_;

 public:
  ColorRGBA() { memset(this, 0, sizeof(ColorRGBA)); }
  ColorRGBA(const ColorRGBA &_o) { memcpy(this, &_o, sizeof(ColorRGBA)); }
  ColorRGBA(uint8_t _r, uint8_t _g, uint8_t _b, uint8_t _a)
    : r_(flatbuffers::EndianScalar(_r)), g_(flatbuffers::EndianScalar(_g)), b_(flatbuffers::EndianScalar(_b)), a_(flatbuffers::EndianScalar(_a)) { }

  uint8_t r() const { return flatbuffers::EndianScalar(r_); }
  uint8_t g() const { return flatbuffers::EndianScalar(g_); }
  uint8_t b() const { return flatbuffers::EndianScalar(b_); }
  uint8_t a() const { return flatbuffers::EndianScalar(a_); }
};
STRUCT_END(ColorRGBA, 4);

struct SceneGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERSION = 4,
    VT_ROOT = 6,
    VT_DESIGNRESOLUTION = 8,
    VT_RESOLUTIONFITWIDTH = 10,
    VT_RESOLUTIONFITHEIGHT = 12,
    VT_SPRITEFRAMES = 14
  };
  const flatbuffers::String *version() const { return GetPointer<const flatbuffers::String *>(VT_VERSION); }
  const NodeTree *root() const { return GetPointer<const NodeTree *>(VT_ROOT); }
  const Size *designResolution() const { return GetStruct<const Size *>(VT_DESIGNRESOLUTION); }
  bool resolutionFitWidth() const { return GetField<uint8_t>(VT_RESOLUTIONFITWIDTH, 0) != 0; }
  bool resolutionFitHeight() const { return GetField<uint8_t>(VT_RESOLUTIONFITHEIGHT, 0) != 0; }
  const flatbuffers::Vector<flatbuffers::Offset<SpriteFrame>> *spriteFrames() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SpriteFrame>> *>(VT_SPRITEFRAMES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ROOT) &&
           verifier.VerifyTable(root()) &&
           VerifyField<Size>(verifier, VT_DESIGNRESOLUTION) &&
           VerifyField<uint8_t>(verifier, VT_RESOLUTIONFITWIDTH) &&
           VerifyField<uint8_t>(verifier, VT_RESOLUTIONFITHEIGHT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SPRITEFRAMES) &&
           verifier.Verify(spriteFrames()) &&
           verifier.VerifyVectorOfTables(spriteFrames()) &&
           verifier.EndTable();
  }
};

struct SceneGraphBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(flatbuffers::Offset<flatbuffers::String> version) { fbb_.AddOffset(SceneGraph::VT_VERSION, version); }
  void add_root(flatbuffers::Offset<NodeTree> root) { fbb_.AddOffset(SceneGraph::VT_ROOT, root); }
  void add_designResolution(const Size *designResolution) { fbb_.AddStruct(SceneGraph::VT_DESIGNRESOLUTION, designResolution); }
  void add_resolutionFitWidth(bool resolutionFitWidth) { fbb_.AddElement<uint8_t>(SceneGraph::VT_RESOLUTIONFITWIDTH, static_cast<uint8_t>(resolutionFitWidth), 0); }
  void add_resolutionFitHeight(bool resolutionFitHeight) { fbb_.AddElement<uint8_t>(SceneGraph::VT_RESOLUTIONFITHEIGHT, static_cast<uint8_t>(resolutionFitHeight), 0); }
  void add_spriteFrames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SpriteFrame>>> spriteFrames) { fbb_.AddOffset(SceneGraph::VT_SPRITEFRAMES, spriteFrames); }
  SceneGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SceneGraphBuilder &operator=(const SceneGraphBuilder &);
  flatbuffers::Offset<SceneGraph> Finish() {
    auto o = flatbuffers::Offset<SceneGraph>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<SceneGraph> CreateSceneGraph(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<NodeTree> root = 0,
    const Size *designResolution = 0,
    bool resolutionFitWidth = false,
    bool resolutionFitHeight = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SpriteFrame>>> spriteFrames = 0) {
  SceneGraphBuilder builder_(_fbb);
  builder_.add_spriteFrames(spriteFrames);
  builder_.add_designResolution(designResolution);
  builder_.add_root(root);
  builder_.add_version(version);
  builder_.add_resolutionFitHeight(resolutionFitHeight);
  builder_.add_resolutionFitWidth(resolutionFitWidth);
  return builder_.Finish();
}

inline flatbuffers::Offset<SceneGraph> CreateSceneGraphDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    flatbuffers::Offset<NodeTree> root = 0,
    const Size *designResolution = 0,
    bool resolutionFitWidth = false,
    bool resolutionFitHeight = false,
    const std::vector<flatbuffers::Offset<SpriteFrame>> *spriteFrames = nullptr) {
  return CreateSceneGraph(_fbb, version ? _fbb.CreateString(version) : 0, root, designResolution, resolutionFitWidth, resolutionFitHeight, spriteFrames ? _fbb.CreateVector<flatbuffers::Offset<SpriteFrame>>(*spriteFrames) : 0);
}

struct NodeTree FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHILDREN = 4,
    VT_OBJECT_TYPE = 6,
    VT_OBJECT = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *children() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *>(VT_CHILDREN); }
  AnyNode object_type() const { return static_cast<AnyNode>(GetField<uint8_t>(VT_OBJECT_TYPE, 0)); }
  const void *object() const { return GetPointer<const void *>(VT_OBJECT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CHILDREN) &&
           verifier.Verify(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyAnyNode(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

struct NodeTreeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> children) { fbb_.AddOffset(NodeTree::VT_CHILDREN, children); }
  void add_object_type(AnyNode object_type) { fbb_.AddElement<uint8_t>(NodeTree::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0); }
  void add_object(flatbuffers::Offset<void> object) { fbb_.AddOffset(NodeTree::VT_OBJECT, object); }
  NodeTreeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NodeTreeBuilder &operator=(const NodeTreeBuilder &);
  flatbuffers::Offset<NodeTree> Finish() {
    auto o = flatbuffers::Offset<NodeTree>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<NodeTree> CreateNodeTree(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> children = 0,
    AnyNode object_type = AnyNode_NONE,
    flatbuffers::Offset<void> object = 0) {
  NodeTreeBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_children(children);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeTree> CreateNodeTreeDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<NodeTree>> *children = nullptr,
    AnyNode object_type = AnyNode_NONE,
    flatbuffers::Offset<void> object = 0) {
  return CreateNodeTree(_fbb, children ? _fbb.CreateVector<flatbuffers::Offset<NodeTree>>(*children) : 0, object_type, object);
}

struct SpriteFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_TEXTUREPATH = 6,
    VT_RECT = 8,
    VT_OFFSET = 10,
    VT_ROTATED = 12,
    VT_ORIGINALSIZE = 14,
    VT_CENTERRECT = 16
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const flatbuffers::String *texturePath() const { return GetPointer<const flatbuffers::String *>(VT_TEXTUREPATH); }
  const Rect *rect() const { return GetStruct<const Rect *>(VT_RECT); }
  const Vec2 *offset() const { return GetStruct<const Vec2 *>(VT_OFFSET); }
  bool rotated() const { return GetField<uint8_t>(VT_ROTATED, 0) != 0; }
  const Size *originalSize() const { return GetStruct<const Size *>(VT_ORIGINALSIZE); }
  const Rect *centerRect() const { return GetStruct<const Rect *>(VT_CENTERRECT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXTUREPATH) &&
           verifier.Verify(texturePath()) &&
           VerifyField<Rect>(verifier, VT_RECT) &&
           VerifyField<Vec2>(verifier, VT_OFFSET) &&
           VerifyField<uint8_t>(verifier, VT_ROTATED) &&
           VerifyField<Size>(verifier, VT_ORIGINALSIZE) &&
           VerifyField<Rect>(verifier, VT_CENTERRECT) &&
           verifier.EndTable();
  }
};

struct SpriteFrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(SpriteFrame::VT_NAME, name); }
  void add_texturePath(flatbuffers::Offset<flatbuffers::String> texturePath) { fbb_.AddOffset(SpriteFrame::VT_TEXTUREPATH, texturePath); }
  void add_rect(const Rect *rect) { fbb_.AddStruct(SpriteFrame::VT_RECT, rect); }
  void add_offset(const Vec2 *offset) { fbb_.AddStruct(SpriteFrame::VT_OFFSET, offset); }
  void add_rotated(bool rotated) { fbb_.AddElement<uint8_t>(SpriteFrame::VT_ROTATED, static_cast<uint8_t>(rotated), 0); }
  void add_originalSize(const Size *originalSize) { fbb_.AddStruct(SpriteFrame::VT_ORIGINALSIZE, originalSize); }
  void add_centerRect(const Rect *centerRect) { fbb_.AddStruct(SpriteFrame::VT_CENTERRECT, centerRect); }
  SpriteFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SpriteFrameBuilder &operator=(const SpriteFrameBuilder &);
  flatbuffers::Offset<SpriteFrame> Finish() {
    auto o = flatbuffers::Offset<SpriteFrame>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<SpriteFrame> CreateSpriteFrame(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> texturePath = 0,
    const Rect *rect = 0,
    const Vec2 *offset = 0,
    bool rotated = false,
    const Size *originalSize = 0,
    const Rect *centerRect = 0) {
  SpriteFrameBuilder builder_(_fbb);
  builder_.add_centerRect(centerRect);
  builder_.add_originalSize(originalSize);
  builder_.add_offset(offset);
  builder_.add_rect(rect);
  builder_.add_texturePath(texturePath);
  builder_.add_name(name);
  builder_.add_rotated(rotated);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpriteFrame> CreateSpriteFrameDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *texturePath = nullptr,
    const Rect *rect = 0,
    const Vec2 *offset = 0,
    bool rotated = false,
    const Size *originalSize = 0,
    const Rect *centerRect = 0) {
  return CreateSpriteFrame(_fbb, name ? _fbb.CreateString(name) : 0, texturePath ? _fbb.CreateString(texturePath) : 0, rect, offset, rotated, originalSize, centerRect);
}

struct CreatorScene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FILENAME = 4
  };
  const flatbuffers::String *filename() const { return GetPointer<const flatbuffers::String *>(VT_FILENAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FILENAME) &&
           verifier.Verify(filename()) &&
           verifier.EndTable();
  }
};

struct CreatorSceneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) { fbb_.AddOffset(CreatorScene::VT_FILENAME, filename); }
  CreatorSceneBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  CreatorSceneBuilder &operator=(const CreatorSceneBuilder &);
  flatbuffers::Offset<CreatorScene> Finish() {
    auto o = flatbuffers::Offset<CreatorScene>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<CreatorScene> CreateCreatorScene(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> filename = 0) {
  CreatorSceneBuilder builder_(_fbb);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline flatbuffers::Offset<CreatorScene> CreateCreatorSceneDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr) {
  return CreateCreatorScene(_fbb, filename ? _fbb.CreateString(filename) : 0);
}

struct Node FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTENTSIZE = 4,
    VT_ENABLED = 6,
    VT_NAME = 8,
    VT_ANCHORPOINT = 10,
    VT_CASCADEOPACITYENABLED = 12,
    VT_COLOR = 14,
    VT_GLOBALZORDER = 16,
    VT_LOCALZORDER = 18,
    VT_OPACITY = 20,
    VT_OPACITYMODIFYRGB = 22,
    VT_POSITION = 24,
    VT_ROTATIONSKEWX = 26,
    VT_ROTATIONSKEWY = 28,
    VT_SCALEX = 30,
    VT_SCALEY = 32,
    VT_SKEWX = 34,
    VT_SKEWY = 36,
    VT_TAG = 38,
    VT_ANIM = 40
  };
  const Size *contentSize() const { return GetStruct<const Size *>(VT_CONTENTSIZE); }
  bool enabled() const { return GetField<uint8_t>(VT_ENABLED, 1) != 0; }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const Vec2 *anchorPoint() const { return GetStruct<const Vec2 *>(VT_ANCHORPOINT); }
  bool cascadeOpacityEnabled() const { return GetField<uint8_t>(VT_CASCADEOPACITYENABLED, 1) != 0; }
  const ColorRGB *color() const { return GetStruct<const ColorRGB *>(VT_COLOR); }
  float globalZOrder() const { return GetField<float>(VT_GLOBALZORDER, 0.0f); }
  int32_t localZOrder() const { return GetField<int32_t>(VT_LOCALZORDER, 0); }
  uint8_t opacity() const { return GetField<uint8_t>(VT_OPACITY, 255); }
  bool opacityModifyRGB() const { return GetField<uint8_t>(VT_OPACITYMODIFYRGB, 1) != 0; }
  const Vec2 *position() const { return GetStruct<const Vec2 *>(VT_POSITION); }
  float rotationSkewX() const { return GetField<float>(VT_ROTATIONSKEWX, 0.0f); }
  float rotationSkewY() const { return GetField<float>(VT_ROTATIONSKEWY, 0.0f); }
  float scaleX() const { return GetField<float>(VT_SCALEX, 1.0f); }
  float scaleY() const { return GetField<float>(VT_SCALEY, 1.0f); }
  float skewX() const { return GetField<float>(VT_SKEWX, 0.0f); }
  float skewY() const { return GetField<float>(VT_SKEWY, 0.0f); }
  int32_t tag() const { return GetField<int32_t>(VT_TAG, 0); }
  const AnimationRef *anim() const { return GetPointer<const AnimationRef *>(VT_ANIM); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Size>(verifier, VT_CONTENTSIZE) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<Vec2>(verifier, VT_ANCHORPOINT) &&
           VerifyField<uint8_t>(verifier, VT_CASCADEOPACITYENABLED) &&
           VerifyField<ColorRGB>(verifier, VT_COLOR) &&
           VerifyField<float>(verifier, VT_GLOBALZORDER) &&
           VerifyField<int32_t>(verifier, VT_LOCALZORDER) &&
           VerifyField<uint8_t>(verifier, VT_OPACITY) &&
           VerifyField<uint8_t>(verifier, VT_OPACITYMODIFYRGB) &&
           VerifyField<Vec2>(verifier, VT_POSITION) &&
           VerifyField<float>(verifier, VT_ROTATIONSKEWX) &&
           VerifyField<float>(verifier, VT_ROTATIONSKEWY) &&
           VerifyField<float>(verifier, VT_SCALEX) &&
           VerifyField<float>(verifier, VT_SCALEY) &&
           VerifyField<float>(verifier, VT_SKEWX) &&
           VerifyField<float>(verifier, VT_SKEWY) &&
           VerifyField<int32_t>(verifier, VT_TAG) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ANIM) &&
           verifier.VerifyTable(anim()) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contentSize(const Size *contentSize) { fbb_.AddStruct(Node::VT_CONTENTSIZE, contentSize); }
  void add_enabled(bool enabled) { fbb_.AddElement<uint8_t>(Node::VT_ENABLED, static_cast<uint8_t>(enabled), 1); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(Node::VT_NAME, name); }
  void add_anchorPoint(const Vec2 *anchorPoint) { fbb_.AddStruct(Node::VT_ANCHORPOINT, anchorPoint); }
  void add_cascadeOpacityEnabled(bool cascadeOpacityEnabled) { fbb_.AddElement<uint8_t>(Node::VT_CASCADEOPACITYENABLED, static_cast<uint8_t>(cascadeOpacityEnabled), 1); }
  void add_color(const ColorRGB *color) { fbb_.AddStruct(Node::VT_COLOR, color); }
  void add_globalZOrder(float globalZOrder) { fbb_.AddElement<float>(Node::VT_GLOBALZORDER, globalZOrder, 0.0f); }
  void add_localZOrder(int32_t localZOrder) { fbb_.AddElement<int32_t>(Node::VT_LOCALZORDER, localZOrder, 0); }
  void add_opacity(uint8_t opacity) { fbb_.AddElement<uint8_t>(Node::VT_OPACITY, opacity, 255); }
  void add_opacityModifyRGB(bool opacityModifyRGB) { fbb_.AddElement<uint8_t>(Node::VT_OPACITYMODIFYRGB, static_cast<uint8_t>(opacityModifyRGB), 1); }
  void add_position(const Vec2 *position) { fbb_.AddStruct(Node::VT_POSITION, position); }
  void add_rotationSkewX(float rotationSkewX) { fbb_.AddElement<float>(Node::VT_ROTATIONSKEWX, rotationSkewX, 0.0f); }
  void add_rotationSkewY(float rotationSkewY) { fbb_.AddElement<float>(Node::VT_ROTATIONSKEWY, rotationSkewY, 0.0f); }
  void add_scaleX(float scaleX) { fbb_.AddElement<float>(Node::VT_SCALEX, scaleX, 1.0f); }
  void add_scaleY(float scaleY) { fbb_.AddElement<float>(Node::VT_SCALEY, scaleY, 1.0f); }
  void add_skewX(float skewX) { fbb_.AddElement<float>(Node::VT_SKEWX, skewX, 0.0f); }
  void add_skewY(float skewY) { fbb_.AddElement<float>(Node::VT_SKEWY, skewY, 0.0f); }
  void add_tag(int32_t tag) { fbb_.AddElement<int32_t>(Node::VT_TAG, tag, 0); }
  void add_anim(flatbuffers::Offset<AnimationRef> anim) { fbb_.AddOffset(Node::VT_ANIM, anim); }
  NodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NodeBuilder &operator=(const NodeBuilder &);
  flatbuffers::Offset<Node> Finish() {
    auto o = flatbuffers::Offset<Node>(fbb_.EndTable(start_, 19));
    return o;
  }
};

inline flatbuffers::Offset<Node> CreateNode(flatbuffers::FlatBufferBuilder &_fbb,
    const Size *contentSize = 0,
    bool enabled = true,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    const Vec2 *anchorPoint = 0,
    bool cascadeOpacityEnabled = true,
    const ColorRGB *color = 0,
    float globalZOrder = 0.0f,
    int32_t localZOrder = 0,
    uint8_t opacity = 255,
    bool opacityModifyRGB = true,
    const Vec2 *position = 0,
    float rotationSkewX = 0.0f,
    float rotationSkewY = 0.0f,
    float scaleX = 1.0f,
    float scaleY = 1.0f,
    float skewX = 0.0f,
    float skewY = 0.0f,
    int32_t tag = 0,
    flatbuffers::Offset<AnimationRef> anim = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_anim(anim);
  builder_.add_tag(tag);
  builder_.add_skewY(skewY);
  builder_.add_skewX(skewX);
  builder_.add_scaleY(scaleY);
  builder_.add_scaleX(scaleX);
  builder_.add_rotationSkewY(rotationSkewY);
  builder_.add_rotationSkewX(rotationSkewX);
  builder_.add_position(position);
  builder_.add_localZOrder(localZOrder);
  builder_.add_globalZOrder(globalZOrder);
  builder_.add_color(color);
  builder_.add_anchorPoint(anchorPoint);
  builder_.add_name(name);
  builder_.add_contentSize(contentSize);
  builder_.add_opacityModifyRGB(opacityModifyRGB);
  builder_.add_opacity(opacity);
  builder_.add_cascadeOpacityEnabled(cascadeOpacityEnabled);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

inline flatbuffers::Offset<Node> CreateNodeDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const Size *contentSize = 0,
    bool enabled = true,
    const char *name = nullptr,
    const Vec2 *anchorPoint = 0,
    bool cascadeOpacityEnabled = true,
    const ColorRGB *color = 0,
    float globalZOrder = 0.0f,
    int32_t localZOrder = 0,
    uint8_t opacity = 255,
    bool opacityModifyRGB = true,
    const Vec2 *position = 0,
    float rotationSkewX = 0.0f,
    float rotationSkewY = 0.0f,
    float scaleX = 1.0f,
    float scaleY = 1.0f,
    float skewX = 0.0f,
    float skewY = 0.0f,
    int32_t tag = 0,
    flatbuffers::Offset<AnimationRef> anim = 0) {
  return CreateNode(_fbb, contentSize, enabled, name ? _fbb.CreateString(name) : 0, anchorPoint, cascadeOpacityEnabled, color, globalZOrder, localZOrder, opacity, opacityModifyRGB, position, rotationSkewX, rotationSkewY, scaleX, scaleY, skewX, skewY, tag, anim);
}

struct Sprite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_SPRITEFRAMENAME = 6,
    VT_SPRITETYPE = 8,
    VT_SRCBLEND = 10,
    VT_DSTBLEND = 12,
    VT_TRIMENABLED = 14,
    VT_SIZEMODE = 16
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *spriteFrameName() const { return GetPointer<const flatbuffers::String *>(VT_SPRITEFRAMENAME); }
  SpriteType spriteType() const { return static_cast<SpriteType>(GetField<int8_t>(VT_SPRITETYPE, 0)); }
  int32_t srcBlend() const { return GetField<int32_t>(VT_SRCBLEND, 770); }
  int32_t dstBlend() const { return GetField<int32_t>(VT_DSTBLEND, 771); }
  bool trimEnabled() const { return GetField<uint8_t>(VT_TRIMENABLED, 0) != 0; }
  SpriteSizeMode sizeMode() const { return static_cast<SpriteSizeMode>(GetField<int8_t>(VT_SIZEMODE, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SPRITEFRAMENAME) &&
           verifier.Verify(spriteFrameName()) &&
           VerifyField<int8_t>(verifier, VT_SPRITETYPE) &&
           VerifyField<int32_t>(verifier, VT_SRCBLEND) &&
           VerifyField<int32_t>(verifier, VT_DSTBLEND) &&
           VerifyField<uint8_t>(verifier, VT_TRIMENABLED) &&
           VerifyField<int8_t>(verifier, VT_SIZEMODE) &&
           verifier.EndTable();
  }
};

struct SpriteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Sprite::VT_NODE, node); }
  void add_spriteFrameName(flatbuffers::Offset<flatbuffers::String> spriteFrameName) { fbb_.AddOffset(Sprite::VT_SPRITEFRAMENAME, spriteFrameName); }
  void add_spriteType(SpriteType spriteType) { fbb_.AddElement<int8_t>(Sprite::VT_SPRITETYPE, static_cast<int8_t>(spriteType), 0); }
  void add_srcBlend(int32_t srcBlend) { fbb_.AddElement<int32_t>(Sprite::VT_SRCBLEND, srcBlend, 770); }
  void add_dstBlend(int32_t dstBlend) { fbb_.AddElement<int32_t>(Sprite::VT_DSTBLEND, dstBlend, 771); }
  void add_trimEnabled(bool trimEnabled) { fbb_.AddElement<uint8_t>(Sprite::VT_TRIMENABLED, static_cast<uint8_t>(trimEnabled), 0); }
  void add_sizeMode(SpriteSizeMode sizeMode) { fbb_.AddElement<int8_t>(Sprite::VT_SIZEMODE, static_cast<int8_t>(sizeMode), 0); }
  SpriteBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SpriteBuilder &operator=(const SpriteBuilder &);
  flatbuffers::Offset<Sprite> Finish() {
    auto o = flatbuffers::Offset<Sprite>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<Sprite> CreateSprite(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> spriteFrameName = 0,
    SpriteType spriteType = SpriteType_Simple,
    int32_t srcBlend = 770,
    int32_t dstBlend = 771,
    bool trimEnabled = false,
    SpriteSizeMode sizeMode = SpriteSizeMode_Custom) {
  SpriteBuilder builder_(_fbb);
  builder_.add_dstBlend(dstBlend);
  builder_.add_srcBlend(srcBlend);
  builder_.add_spriteFrameName(spriteFrameName);
  builder_.add_node(node);
  builder_.add_sizeMode(sizeMode);
  builder_.add_trimEnabled(trimEnabled);
  builder_.add_spriteType(spriteType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Sprite> CreateSpriteDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *spriteFrameName = nullptr,
    SpriteType spriteType = SpriteType_Simple,
    int32_t srcBlend = 770,
    int32_t dstBlend = 771,
    bool trimEnabled = false,
    SpriteSizeMode sizeMode = SpriteSizeMode_Custom) {
  return CreateSprite(_fbb, node, spriteFrameName ? _fbb.CreateString(spriteFrameName) : 0, spriteType, srcBlend, dstBlend, trimEnabled, sizeMode);
}

struct Label FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_LABELTEXT = 6,
    VT_HORIZONTALALIGNMENT = 8,
    VT_VERTICALALIGNMENT = 10,
    VT_LINEHEIGHT = 12,
    VT_FONTNAME = 14,
    VT_FONTSIZE = 16,
    VT_FONTTYPE = 18,
    VT_OVERFLOWTYPE = 20,
    VT_ENABLEWRAP = 22
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *labelText() const { return GetPointer<const flatbuffers::String *>(VT_LABELTEXT); }
  HorizontalAlignment horizontalAlignment() const { return static_cast<HorizontalAlignment>(GetField<int8_t>(VT_HORIZONTALALIGNMENT, 0)); }
  VerticalAlignment verticalAlignment() const { return static_cast<VerticalAlignment>(GetField<int8_t>(VT_VERTICALALIGNMENT, 0)); }
  float lineHeight() const { return GetField<float>(VT_LINEHEIGHT, 0.0f); }
  const flatbuffers::String *fontName() const { return GetPointer<const flatbuffers::String *>(VT_FONTNAME); }
  float fontSize() const { return GetField<float>(VT_FONTSIZE, 0.0f); }
  FontType fontType() const { return static_cast<FontType>(GetField<int8_t>(VT_FONTTYPE, 0)); }
  LabelOverflowType overflowType() const { return static_cast<LabelOverflowType>(GetField<int8_t>(VT_OVERFLOWTYPE, 0)); }
  bool enableWrap() const { return GetField<uint8_t>(VT_ENABLEWRAP, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LABELTEXT) &&
           verifier.Verify(labelText()) &&
           VerifyField<int8_t>(verifier, VT_HORIZONTALALIGNMENT) &&
           VerifyField<int8_t>(verifier, VT_VERTICALALIGNMENT) &&
           VerifyField<float>(verifier, VT_LINEHEIGHT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FONTNAME) &&
           verifier.Verify(fontName()) &&
           VerifyField<float>(verifier, VT_FONTSIZE) &&
           VerifyField<int8_t>(verifier, VT_FONTTYPE) &&
           VerifyField<int8_t>(verifier, VT_OVERFLOWTYPE) &&
           VerifyField<uint8_t>(verifier, VT_ENABLEWRAP) &&
           verifier.EndTable();
  }
};

struct LabelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Label::VT_NODE, node); }
  void add_labelText(flatbuffers::Offset<flatbuffers::String> labelText) { fbb_.AddOffset(Label::VT_LABELTEXT, labelText); }
  void add_horizontalAlignment(HorizontalAlignment horizontalAlignment) { fbb_.AddElement<int8_t>(Label::VT_HORIZONTALALIGNMENT, static_cast<int8_t>(horizontalAlignment), 0); }
  void add_verticalAlignment(VerticalAlignment verticalAlignment) { fbb_.AddElement<int8_t>(Label::VT_VERTICALALIGNMENT, static_cast<int8_t>(verticalAlignment), 0); }
  void add_lineHeight(float lineHeight) { fbb_.AddElement<float>(Label::VT_LINEHEIGHT, lineHeight, 0.0f); }
  void add_fontName(flatbuffers::Offset<flatbuffers::String> fontName) { fbb_.AddOffset(Label::VT_FONTNAME, fontName); }
  void add_fontSize(float fontSize) { fbb_.AddElement<float>(Label::VT_FONTSIZE, fontSize, 0.0f); }
  void add_fontType(FontType fontType) { fbb_.AddElement<int8_t>(Label::VT_FONTTYPE, static_cast<int8_t>(fontType), 0); }
  void add_overflowType(LabelOverflowType overflowType) { fbb_.AddElement<int8_t>(Label::VT_OVERFLOWTYPE, static_cast<int8_t>(overflowType), 0); }
  void add_enableWrap(bool enableWrap) { fbb_.AddElement<uint8_t>(Label::VT_ENABLEWRAP, static_cast<uint8_t>(enableWrap), 0); }
  LabelBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LabelBuilder &operator=(const LabelBuilder &);
  flatbuffers::Offset<Label> Finish() {
    auto o = flatbuffers::Offset<Label>(fbb_.EndTable(start_, 10));
    return o;
  }
};

inline flatbuffers::Offset<Label> CreateLabel(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> labelText = 0,
    HorizontalAlignment horizontalAlignment = HorizontalAlignment_Left,
    VerticalAlignment verticalAlignment = VerticalAlignment_Top,
    float lineHeight = 0.0f,
    flatbuffers::Offset<flatbuffers::String> fontName = 0,
    float fontSize = 0.0f,
    FontType fontType = FontType_System,
    LabelOverflowType overflowType = LabelOverflowType_None,
    bool enableWrap = false) {
  LabelBuilder builder_(_fbb);
  builder_.add_fontSize(fontSize);
  builder_.add_fontName(fontName);
  builder_.add_lineHeight(lineHeight);
  builder_.add_labelText(labelText);
  builder_.add_node(node);
  builder_.add_enableWrap(enableWrap);
  builder_.add_overflowType(overflowType);
  builder_.add_fontType(fontType);
  builder_.add_verticalAlignment(verticalAlignment);
  builder_.add_horizontalAlignment(horizontalAlignment);
  return builder_.Finish();
}

inline flatbuffers::Offset<Label> CreateLabelDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *labelText = nullptr,
    HorizontalAlignment horizontalAlignment = HorizontalAlignment_Left,
    VerticalAlignment verticalAlignment = VerticalAlignment_Top,
    float lineHeight = 0.0f,
    const char *fontName = nullptr,
    float fontSize = 0.0f,
    FontType fontType = FontType_System,
    LabelOverflowType overflowType = LabelOverflowType_None,
    bool enableWrap = false) {
  return CreateLabel(_fbb, node, labelText ? _fbb.CreateString(labelText) : 0, horizontalAlignment, verticalAlignment, lineHeight, fontName ? _fbb.CreateString(fontName) : 0, fontSize, fontType, overflowType, enableWrap);
}

struct RichText FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_TEXT = 6,
    VT_HORIZONTALALIGNMENT = 8,
    VT_FONTSIZE = 10,
    VT_MAXWIDTH = 12,
    VT_LINEHEIGHT = 14,
    VT_FONTFILENAME = 16
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *text() const { return GetPointer<const flatbuffers::String *>(VT_TEXT); }
  HorizontalAlignment horizontalAlignment() const { return static_cast<HorizontalAlignment>(GetField<int8_t>(VT_HORIZONTALALIGNMENT, 0)); }
  float fontSize() const { return GetField<float>(VT_FONTSIZE, 0.0f); }
  float maxWidth() const { return GetField<float>(VT_MAXWIDTH, 0.0f); }
  float lineHeight() const { return GetField<float>(VT_LINEHEIGHT, 0.0f); }
  const flatbuffers::String *fontFilename() const { return GetPointer<const flatbuffers::String *>(VT_FONTFILENAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           VerifyField<int8_t>(verifier, VT_HORIZONTALALIGNMENT) &&
           VerifyField<float>(verifier, VT_FONTSIZE) &&
           VerifyField<float>(verifier, VT_MAXWIDTH) &&
           VerifyField<float>(verifier, VT_LINEHEIGHT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FONTFILENAME) &&
           verifier.Verify(fontFilename()) &&
           verifier.EndTable();
  }
};

struct RichTextBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(RichText::VT_NODE, node); }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) { fbb_.AddOffset(RichText::VT_TEXT, text); }
  void add_horizontalAlignment(HorizontalAlignment horizontalAlignment) { fbb_.AddElement<int8_t>(RichText::VT_HORIZONTALALIGNMENT, static_cast<int8_t>(horizontalAlignment), 0); }
  void add_fontSize(float fontSize) { fbb_.AddElement<float>(RichText::VT_FONTSIZE, fontSize, 0.0f); }
  void add_maxWidth(float maxWidth) { fbb_.AddElement<float>(RichText::VT_MAXWIDTH, maxWidth, 0.0f); }
  void add_lineHeight(float lineHeight) { fbb_.AddElement<float>(RichText::VT_LINEHEIGHT, lineHeight, 0.0f); }
  void add_fontFilename(flatbuffers::Offset<flatbuffers::String> fontFilename) { fbb_.AddOffset(RichText::VT_FONTFILENAME, fontFilename); }
  RichTextBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RichTextBuilder &operator=(const RichTextBuilder &);
  flatbuffers::Offset<RichText> Finish() {
    auto o = flatbuffers::Offset<RichText>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<RichText> CreateRichText(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    HorizontalAlignment horizontalAlignment = HorizontalAlignment_Left,
    float fontSize = 0.0f,
    float maxWidth = 0.0f,
    float lineHeight = 0.0f,
    flatbuffers::Offset<flatbuffers::String> fontFilename = 0) {
  RichTextBuilder builder_(_fbb);
  builder_.add_fontFilename(fontFilename);
  builder_.add_lineHeight(lineHeight);
  builder_.add_maxWidth(maxWidth);
  builder_.add_fontSize(fontSize);
  builder_.add_text(text);
  builder_.add_node(node);
  builder_.add_horizontalAlignment(horizontalAlignment);
  return builder_.Finish();
}

inline flatbuffers::Offset<RichText> CreateRichTextDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *text = nullptr,
    HorizontalAlignment horizontalAlignment = HorizontalAlignment_Left,
    float fontSize = 0.0f,
    float maxWidth = 0.0f,
    float lineHeight = 0.0f,
    const char *fontFilename = nullptr) {
  return CreateRichText(_fbb, node, text ? _fbb.CreateString(text) : 0, horizontalAlignment, fontSize, maxWidth, lineHeight, fontFilename ? _fbb.CreateString(fontFilename) : 0);
}

struct Particle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_PARTICLEFILENAME = 6
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *particleFilename() const { return GetPointer<const flatbuffers::String *>(VT_PARTICLEFILENAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PARTICLEFILENAME) &&
           verifier.Verify(particleFilename()) &&
           verifier.EndTable();
  }
};

struct ParticleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Particle::VT_NODE, node); }
  void add_particleFilename(flatbuffers::Offset<flatbuffers::String> particleFilename) { fbb_.AddOffset(Particle::VT_PARTICLEFILENAME, particleFilename); }
  ParticleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ParticleBuilder &operator=(const ParticleBuilder &);
  flatbuffers::Offset<Particle> Finish() {
    auto o = flatbuffers::Offset<Particle>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Particle> CreateParticle(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> particleFilename = 0) {
  ParticleBuilder builder_(_fbb);
  builder_.add_particleFilename(particleFilename);
  builder_.add_node(node);
  return builder_.Finish();
}

inline flatbuffers::Offset<Particle> CreateParticleDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *particleFilename = nullptr) {
  return CreateParticle(_fbb, node, particleFilename ? _fbb.CreateString(particleFilename) : 0);
}

struct TileMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_TMXFILENAME = 6,
    VT_DESIREDCONTENTSIZE = 8
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *tmxFilename() const { return GetPointer<const flatbuffers::String *>(VT_TMXFILENAME); }
  const Size *desiredContentSize() const { return GetStruct<const Size *>(VT_DESIREDCONTENTSIZE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TMXFILENAME) &&
           verifier.Verify(tmxFilename()) &&
           VerifyField<Size>(verifier, VT_DESIREDCONTENTSIZE) &&
           verifier.EndTable();
  }
};

struct TileMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(TileMap::VT_NODE, node); }
  void add_tmxFilename(flatbuffers::Offset<flatbuffers::String> tmxFilename) { fbb_.AddOffset(TileMap::VT_TMXFILENAME, tmxFilename); }
  void add_desiredContentSize(const Size *desiredContentSize) { fbb_.AddStruct(TileMap::VT_DESIREDCONTENTSIZE, desiredContentSize); }
  TileMapBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TileMapBuilder &operator=(const TileMapBuilder &);
  flatbuffers::Offset<TileMap> Finish() {
    auto o = flatbuffers::Offset<TileMap>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<TileMap> CreateTileMap(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> tmxFilename = 0,
    const Size *desiredContentSize = 0) {
  TileMapBuilder builder_(_fbb);
  builder_.add_desiredContentSize(desiredContentSize);
  builder_.add_tmxFilename(tmxFilename);
  builder_.add_node(node);
  return builder_.Finish();
}

inline flatbuffers::Offset<TileMap> CreateTileMapDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *tmxFilename = nullptr,
    const Size *desiredContentSize = 0) {
  return CreateTileMap(_fbb, node, tmxFilename ? _fbb.CreateString(tmxFilename) : 0, desiredContentSize);
}

struct Scene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           verifier.EndTable();
  }
};

struct SceneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Scene::VT_NODE, node); }
  SceneBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SceneBuilder &operator=(const SceneBuilder &);
  flatbuffers::Offset<Scene> Finish() {
    auto o = flatbuffers::Offset<Scene>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Scene> CreateScene(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0) {
  SceneBuilder builder_(_fbb);
  builder_.add_node(node);
  return builder_.Finish();
}

struct Button FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_TRANSITION = 6,
    VT_ZOOMSCALE = 8,
    VT_SPRITEFRAMENAME = 10,
    VT_PRESSEDSPRITEFRAMENAME = 12,
    VT_DISABLEDSPRITEFRAMENAME = 14,
    VT_IGNORECONTENTADAPTWITHSIZE = 16
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  int32_t transition() const { return GetField<int32_t>(VT_TRANSITION, 0); }
  float zoomScale() const { return GetField<float>(VT_ZOOMSCALE, 0.0f); }
  const flatbuffers::String *spriteFrameName() const { return GetPointer<const flatbuffers::String *>(VT_SPRITEFRAMENAME); }
  const flatbuffers::String *pressedSpriteFrameName() const { return GetPointer<const flatbuffers::String *>(VT_PRESSEDSPRITEFRAMENAME); }
  const flatbuffers::String *disabledSpriteFrameName() const { return GetPointer<const flatbuffers::String *>(VT_DISABLEDSPRITEFRAMENAME); }
  bool ignoreContentAdaptWithSize() const { return GetField<uint8_t>(VT_IGNORECONTENTADAPTWITHSIZE, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<int32_t>(verifier, VT_TRANSITION) &&
           VerifyField<float>(verifier, VT_ZOOMSCALE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SPRITEFRAMENAME) &&
           verifier.Verify(spriteFrameName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PRESSEDSPRITEFRAMENAME) &&
           verifier.Verify(pressedSpriteFrameName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DISABLEDSPRITEFRAMENAME) &&
           verifier.Verify(disabledSpriteFrameName()) &&
           VerifyField<uint8_t>(verifier, VT_IGNORECONTENTADAPTWITHSIZE) &&
           verifier.EndTable();
  }
};

struct ButtonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Button::VT_NODE, node); }
  void add_transition(int32_t transition) { fbb_.AddElement<int32_t>(Button::VT_TRANSITION, transition, 0); }
  void add_zoomScale(float zoomScale) { fbb_.AddElement<float>(Button::VT_ZOOMSCALE, zoomScale, 0.0f); }
  void add_spriteFrameName(flatbuffers::Offset<flatbuffers::String> spriteFrameName) { fbb_.AddOffset(Button::VT_SPRITEFRAMENAME, spriteFrameName); }
  void add_pressedSpriteFrameName(flatbuffers::Offset<flatbuffers::String> pressedSpriteFrameName) { fbb_.AddOffset(Button::VT_PRESSEDSPRITEFRAMENAME, pressedSpriteFrameName); }
  void add_disabledSpriteFrameName(flatbuffers::Offset<flatbuffers::String> disabledSpriteFrameName) { fbb_.AddOffset(Button::VT_DISABLEDSPRITEFRAMENAME, disabledSpriteFrameName); }
  void add_ignoreContentAdaptWithSize(bool ignoreContentAdaptWithSize) { fbb_.AddElement<uint8_t>(Button::VT_IGNORECONTENTADAPTWITHSIZE, static_cast<uint8_t>(ignoreContentAdaptWithSize), 0); }
  ButtonBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ButtonBuilder &operator=(const ButtonBuilder &);
  flatbuffers::Offset<Button> Finish() {
    auto o = flatbuffers::Offset<Button>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<Button> CreateButton(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    int32_t transition = 0,
    float zoomScale = 0.0f,
    flatbuffers::Offset<flatbuffers::String> spriteFrameName = 0,
    flatbuffers::Offset<flatbuffers::String> pressedSpriteFrameName = 0,
    flatbuffers::Offset<flatbuffers::String> disabledSpriteFrameName = 0,
    bool ignoreContentAdaptWithSize = false) {
  ButtonBuilder builder_(_fbb);
  builder_.add_disabledSpriteFrameName(disabledSpriteFrameName);
  builder_.add_pressedSpriteFrameName(pressedSpriteFrameName);
  builder_.add_spriteFrameName(spriteFrameName);
  builder_.add_zoomScale(zoomScale);
  builder_.add_transition(transition);
  builder_.add_node(node);
  builder_.add_ignoreContentAdaptWithSize(ignoreContentAdaptWithSize);
  return builder_.Finish();
}

inline flatbuffers::Offset<Button> CreateButtonDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    int32_t transition = 0,
    float zoomScale = 0.0f,
    const char *spriteFrameName = nullptr,
    const char *pressedSpriteFrameName = nullptr,
    const char *disabledSpriteFrameName = nullptr,
    bool ignoreContentAdaptWithSize = false) {
  return CreateButton(_fbb, node, transition, zoomScale, spriteFrameName ? _fbb.CreateString(spriteFrameName) : 0, pressedSpriteFrameName ? _fbb.CreateString(pressedSpriteFrameName) : 0, disabledSpriteFrameName ? _fbb.CreateString(disabledSpriteFrameName) : 0, ignoreContentAdaptWithSize);
}

struct ProgressBar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_PERCENT = 6,
    VT_BACKGROUNDSPRITEFRAMENAME = 8,
    VT_BARSPRITEFRAMENAME = 10,
    VT_BARSPRITETYPE = 12,
    VT_REVERSE = 14
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  float percent() const { return GetField<float>(VT_PERCENT, 0.0f); }
  const flatbuffers::String *backgroundSpriteFrameName() const { return GetPointer<const flatbuffers::String *>(VT_BACKGROUNDSPRITEFRAMENAME); }
  const flatbuffers::String *barSpriteFrameName() const { return GetPointer<const flatbuffers::String *>(VT_BARSPRITEFRAMENAME); }
  int32_t barSpriteType() const { return GetField<int32_t>(VT_BARSPRITETYPE, 0); }
  bool reverse() const { return GetField<uint8_t>(VT_REVERSE, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<float>(verifier, VT_PERCENT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BACKGROUNDSPRITEFRAMENAME) &&
           verifier.Verify(backgroundSpriteFrameName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BARSPRITEFRAMENAME) &&
           verifier.Verify(barSpriteFrameName()) &&
           VerifyField<int32_t>(verifier, VT_BARSPRITETYPE) &&
           VerifyField<uint8_t>(verifier, VT_REVERSE) &&
           verifier.EndTable();
  }
};

struct ProgressBarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(ProgressBar::VT_NODE, node); }
  void add_percent(float percent) { fbb_.AddElement<float>(ProgressBar::VT_PERCENT, percent, 0.0f); }
  void add_backgroundSpriteFrameName(flatbuffers::Offset<flatbuffers::String> backgroundSpriteFrameName) { fbb_.AddOffset(ProgressBar::VT_BACKGROUNDSPRITEFRAMENAME, backgroundSpriteFrameName); }
  void add_barSpriteFrameName(flatbuffers::Offset<flatbuffers::String> barSpriteFrameName) { fbb_.AddOffset(ProgressBar::VT_BARSPRITEFRAMENAME, barSpriteFrameName); }
  void add_barSpriteType(int32_t barSpriteType) { fbb_.AddElement<int32_t>(ProgressBar::VT_BARSPRITETYPE, barSpriteType, 0); }
  void add_reverse(bool reverse) { fbb_.AddElement<uint8_t>(ProgressBar::VT_REVERSE, static_cast<uint8_t>(reverse), 0); }
  ProgressBarBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ProgressBarBuilder &operator=(const ProgressBarBuilder &);
  flatbuffers::Offset<ProgressBar> Finish() {
    auto o = flatbuffers::Offset<ProgressBar>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<ProgressBar> CreateProgressBar(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    float percent = 0.0f,
    flatbuffers::Offset<flatbuffers::String> backgroundSpriteFrameName = 0,
    flatbuffers::Offset<flatbuffers::String> barSpriteFrameName = 0,
    int32_t barSpriteType = 0,
    bool reverse = false) {
  ProgressBarBuilder builder_(_fbb);
  builder_.add_barSpriteType(barSpriteType);
  builder_.add_barSpriteFrameName(barSpriteFrameName);
  builder_.add_backgroundSpriteFrameName(backgroundSpriteFrameName);
  builder_.add_percent(percent);
  builder_.add_node(node);
  builder_.add_reverse(reverse);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProgressBar> CreateProgressBarDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    float percent = 0.0f,
    const char *backgroundSpriteFrameName = nullptr,
    const char *barSpriteFrameName = nullptr,
    int32_t barSpriteType = 0,
    bool reverse = false) {
  return CreateProgressBar(_fbb, node, percent, backgroundSpriteFrameName ? _fbb.CreateString(backgroundSpriteFrameName) : 0, barSpriteFrameName ? _fbb.CreateString(barSpriteFrameName) : 0, barSpriteType, reverse);
}

struct ScrollView FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_BACKGROUNDIMAGE = 6,
    VT_BACKGROUNDIMAGESCALE9ENABLED = 8,
    VT_BACKGROUNDIMAGECOLOR = 10,
    VT_DIRECTION = 12,
    VT_BOUNCEENABLED = 14,
    VT_INNERCONTAINERSIZE = 16
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *backgroundImage() const { return GetPointer<const flatbuffers::String *>(VT_BACKGROUNDIMAGE); }
  bool backgroundImageScale9Enabled() const { return GetField<uint8_t>(VT_BACKGROUNDIMAGESCALE9ENABLED, 0) != 0; }
  const ColorRGB *backgroundImageColor() const { return GetStruct<const ColorRGB *>(VT_BACKGROUNDIMAGECOLOR); }
  ScrollViewDirection direction() const { return static_cast<ScrollViewDirection>(GetField<int8_t>(VT_DIRECTION, 0)); }
  bool bounceEnabled() const { return GetField<uint8_t>(VT_BOUNCEENABLED, 0) != 0; }
  const Size *innerContainerSize() const { return GetStruct<const Size *>(VT_INNERCONTAINERSIZE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BACKGROUNDIMAGE) &&
           verifier.Verify(backgroundImage()) &&
           VerifyField<uint8_t>(verifier, VT_BACKGROUNDIMAGESCALE9ENABLED) &&
           VerifyField<ColorRGB>(verifier, VT_BACKGROUNDIMAGECOLOR) &&
           VerifyField<int8_t>(verifier, VT_DIRECTION) &&
           VerifyField<uint8_t>(verifier, VT_BOUNCEENABLED) &&
           VerifyField<Size>(verifier, VT_INNERCONTAINERSIZE) &&
           verifier.EndTable();
  }
};

struct ScrollViewBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(ScrollView::VT_NODE, node); }
  void add_backgroundImage(flatbuffers::Offset<flatbuffers::String> backgroundImage) { fbb_.AddOffset(ScrollView::VT_BACKGROUNDIMAGE, backgroundImage); }
  void add_backgroundImageScale9Enabled(bool backgroundImageScale9Enabled) { fbb_.AddElement<uint8_t>(ScrollView::VT_BACKGROUNDIMAGESCALE9ENABLED, static_cast<uint8_t>(backgroundImageScale9Enabled), 0); }
  void add_backgroundImageColor(const ColorRGB *backgroundImageColor) { fbb_.AddStruct(ScrollView::VT_BACKGROUNDIMAGECOLOR, backgroundImageColor); }
  void add_direction(ScrollViewDirection direction) { fbb_.AddElement<int8_t>(ScrollView::VT_DIRECTION, static_cast<int8_t>(direction), 0); }
  void add_bounceEnabled(bool bounceEnabled) { fbb_.AddElement<uint8_t>(ScrollView::VT_BOUNCEENABLED, static_cast<uint8_t>(bounceEnabled), 0); }
  void add_innerContainerSize(const Size *innerContainerSize) { fbb_.AddStruct(ScrollView::VT_INNERCONTAINERSIZE, innerContainerSize); }
  ScrollViewBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ScrollViewBuilder &operator=(const ScrollViewBuilder &);
  flatbuffers::Offset<ScrollView> Finish() {
    auto o = flatbuffers::Offset<ScrollView>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<ScrollView> CreateScrollView(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> backgroundImage = 0,
    bool backgroundImageScale9Enabled = false,
    const ColorRGB *backgroundImageColor = 0,
    ScrollViewDirection direction = ScrollViewDirection_None,
    bool bounceEnabled = false,
    const Size *innerContainerSize = 0) {
  ScrollViewBuilder builder_(_fbb);
  builder_.add_innerContainerSize(innerContainerSize);
  builder_.add_backgroundImageColor(backgroundImageColor);
  builder_.add_backgroundImage(backgroundImage);
  builder_.add_node(node);
  builder_.add_bounceEnabled(bounceEnabled);
  builder_.add_direction(direction);
  builder_.add_backgroundImageScale9Enabled(backgroundImageScale9Enabled);
  return builder_.Finish();
}

inline flatbuffers::Offset<ScrollView> CreateScrollViewDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *backgroundImage = nullptr,
    bool backgroundImageScale9Enabled = false,
    const ColorRGB *backgroundImageColor = 0,
    ScrollViewDirection direction = ScrollViewDirection_None,
    bool bounceEnabled = false,
    const Size *innerContainerSize = 0) {
  return CreateScrollView(_fbb, node, backgroundImage ? _fbb.CreateString(backgroundImage) : 0, backgroundImageScale9Enabled, backgroundImageColor, direction, bounceEnabled, innerContainerSize);
}

struct EditBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_BACKGROUNDIMAGE = 6,
    VT_RETURNTYPE = 8,
    VT_INPUTFLAG = 10,
    VT_INPUTMODE = 12,
    VT_FONTSIZE = 14,
    VT_FONTCOLOR = 16,
    VT_PLACEHOLDER = 18,
    VT_PLACEHOLDERFONTSIZE = 20,
    VT_PLACEHOLDERFONTCOLOR = 22,
    VT_MAXLENGTH = 24,
    VT_TEXT = 26
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *backgroundImage() const { return GetPointer<const flatbuffers::String *>(VT_BACKGROUNDIMAGE); }
  EditBoxReturnType returnType() const { return static_cast<EditBoxReturnType>(GetField<int8_t>(VT_RETURNTYPE, 0)); }
  EditBoxInputFlag inputFlag() const { return static_cast<EditBoxInputFlag>(GetField<int8_t>(VT_INPUTFLAG, 0)); }
  EditBoxInputMode inputMode() const { return static_cast<EditBoxInputMode>(GetField<int8_t>(VT_INPUTMODE, 0)); }
  int32_t fontSize() const { return GetField<int32_t>(VT_FONTSIZE, 0); }
  const ColorRGB *fontColor() const { return GetStruct<const ColorRGB *>(VT_FONTCOLOR); }
  const flatbuffers::String *placeholder() const { return GetPointer<const flatbuffers::String *>(VT_PLACEHOLDER); }
  int32_t placeholderFontSize() const { return GetField<int32_t>(VT_PLACEHOLDERFONTSIZE, 0); }
  const ColorRGB *placeholderFontColor() const { return GetStruct<const ColorRGB *>(VT_PLACEHOLDERFONTCOLOR); }
  int32_t maxLength() const { return GetField<int32_t>(VT_MAXLENGTH, 0); }
  const flatbuffers::String *text() const { return GetPointer<const flatbuffers::String *>(VT_TEXT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BACKGROUNDIMAGE) &&
           verifier.Verify(backgroundImage()) &&
           VerifyField<int8_t>(verifier, VT_RETURNTYPE) &&
           VerifyField<int8_t>(verifier, VT_INPUTFLAG) &&
           VerifyField<int8_t>(verifier, VT_INPUTMODE) &&
           VerifyField<int32_t>(verifier, VT_FONTSIZE) &&
           VerifyField<ColorRGB>(verifier, VT_FONTCOLOR) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PLACEHOLDER) &&
           verifier.Verify(placeholder()) &&
           VerifyField<int32_t>(verifier, VT_PLACEHOLDERFONTSIZE) &&
           VerifyField<ColorRGB>(verifier, VT_PLACEHOLDERFONTCOLOR) &&
           VerifyField<int32_t>(verifier, VT_MAXLENGTH) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           verifier.EndTable();
  }
};

struct EditBoxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(EditBox::VT_NODE, node); }
  void add_backgroundImage(flatbuffers::Offset<flatbuffers::String> backgroundImage) { fbb_.AddOffset(EditBox::VT_BACKGROUNDIMAGE, backgroundImage); }
  void add_returnType(EditBoxReturnType returnType) { fbb_.AddElement<int8_t>(EditBox::VT_RETURNTYPE, static_cast<int8_t>(returnType), 0); }
  void add_inputFlag(EditBoxInputFlag inputFlag) { fbb_.AddElement<int8_t>(EditBox::VT_INPUTFLAG, static_cast<int8_t>(inputFlag), 0); }
  void add_inputMode(EditBoxInputMode inputMode) { fbb_.AddElement<int8_t>(EditBox::VT_INPUTMODE, static_cast<int8_t>(inputMode), 0); }
  void add_fontSize(int32_t fontSize) { fbb_.AddElement<int32_t>(EditBox::VT_FONTSIZE, fontSize, 0); }
  void add_fontColor(const ColorRGB *fontColor) { fbb_.AddStruct(EditBox::VT_FONTCOLOR, fontColor); }
  void add_placeholder(flatbuffers::Offset<flatbuffers::String> placeholder) { fbb_.AddOffset(EditBox::VT_PLACEHOLDER, placeholder); }
  void add_placeholderFontSize(int32_t placeholderFontSize) { fbb_.AddElement<int32_t>(EditBox::VT_PLACEHOLDERFONTSIZE, placeholderFontSize, 0); }
  void add_placeholderFontColor(const ColorRGB *placeholderFontColor) { fbb_.AddStruct(EditBox::VT_PLACEHOLDERFONTCOLOR, placeholderFontColor); }
  void add_maxLength(int32_t maxLength) { fbb_.AddElement<int32_t>(EditBox::VT_MAXLENGTH, maxLength, 0); }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) { fbb_.AddOffset(EditBox::VT_TEXT, text); }
  EditBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  EditBoxBuilder &operator=(const EditBoxBuilder &);
  flatbuffers::Offset<EditBox> Finish() {
    auto o = flatbuffers::Offset<EditBox>(fbb_.EndTable(start_, 12));
    return o;
  }
};

inline flatbuffers::Offset<EditBox> CreateEditBox(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> backgroundImage = 0,
    EditBoxReturnType returnType = EditBoxReturnType_Default,
    EditBoxInputFlag inputFlag = EditBoxInputFlag_Password,
    EditBoxInputMode inputMode = EditBoxInputMode_Any,
    int32_t fontSize = 0,
    const ColorRGB *fontColor = 0,
    flatbuffers::Offset<flatbuffers::String> placeholder = 0,
    int32_t placeholderFontSize = 0,
    const ColorRGB *placeholderFontColor = 0,
    int32_t maxLength = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0) {
  EditBoxBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_maxLength(maxLength);
  builder_.add_placeholderFontColor(placeholderFontColor);
  builder_.add_placeholderFontSize(placeholderFontSize);
  builder_.add_placeholder(placeholder);
  builder_.add_fontColor(fontColor);
  builder_.add_fontSize(fontSize);
  builder_.add_backgroundImage(backgroundImage);
  builder_.add_node(node);
  builder_.add_inputMode(inputMode);
  builder_.add_inputFlag(inputFlag);
  builder_.add_returnType(returnType);
  return builder_.Finish();
}

inline flatbuffers::Offset<EditBox> CreateEditBoxDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *backgroundImage = nullptr,
    EditBoxReturnType returnType = EditBoxReturnType_Default,
    EditBoxInputFlag inputFlag = EditBoxInputFlag_Password,
    EditBoxInputMode inputMode = EditBoxInputMode_Any,
    int32_t fontSize = 0,
    const ColorRGB *fontColor = 0,
    const char *placeholder = nullptr,
    int32_t placeholderFontSize = 0,
    const ColorRGB *placeholderFontColor = 0,
    int32_t maxLength = 0,
    const char *text = nullptr) {
  return CreateEditBox(_fbb, node, backgroundImage ? _fbb.CreateString(backgroundImage) : 0, returnType, inputFlag, inputMode, fontSize, fontColor, placeholder ? _fbb.CreateString(placeholder) : 0, placeholderFontSize, placeholderFontColor, maxLength, text ? _fbb.CreateString(text) : 0);
}

struct SpineSkeleton FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_JSONFILE = 6,
    VT_ATLASFILE = 8,
    VT_DEFAULTSKIN = 10,
    VT_DEFAULTANIMATION = 12,
    VT_LOOP = 14,
    VT_PREMULTIPLIEDALPHA = 16,
    VT_TIMESCALE = 18,
    VT_DEBUGSLOTS = 20,
    VT_DEBUGBONES = 22
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *jsonFile() const { return GetPointer<const flatbuffers::String *>(VT_JSONFILE); }
  const flatbuffers::String *atlasFile() const { return GetPointer<const flatbuffers::String *>(VT_ATLASFILE); }
  const flatbuffers::String *defaultSkin() const { return GetPointer<const flatbuffers::String *>(VT_DEFAULTSKIN); }
  const flatbuffers::String *defaultAnimation() const { return GetPointer<const flatbuffers::String *>(VT_DEFAULTANIMATION); }
  bool loop() const { return GetField<uint8_t>(VT_LOOP, 0) != 0; }
  bool premultipliedAlpha() const { return GetField<uint8_t>(VT_PREMULTIPLIEDALPHA, 0) != 0; }
  float timeScale() const { return GetField<float>(VT_TIMESCALE, 1.0f); }
  bool debugSlots() const { return GetField<uint8_t>(VT_DEBUGSLOTS, 0) != 0; }
  bool debugBones() const { return GetField<uint8_t>(VT_DEBUGBONES, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_JSONFILE) &&
           verifier.Verify(jsonFile()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ATLASFILE) &&
           verifier.Verify(atlasFile()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DEFAULTSKIN) &&
           verifier.Verify(defaultSkin()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DEFAULTANIMATION) &&
           verifier.Verify(defaultAnimation()) &&
           VerifyField<uint8_t>(verifier, VT_LOOP) &&
           VerifyField<uint8_t>(verifier, VT_PREMULTIPLIEDALPHA) &&
           VerifyField<float>(verifier, VT_TIMESCALE) &&
           VerifyField<uint8_t>(verifier, VT_DEBUGSLOTS) &&
           VerifyField<uint8_t>(verifier, VT_DEBUGBONES) &&
           verifier.EndTable();
  }
};

struct SpineSkeletonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(SpineSkeleton::VT_NODE, node); }
  void add_jsonFile(flatbuffers::Offset<flatbuffers::String> jsonFile) { fbb_.AddOffset(SpineSkeleton::VT_JSONFILE, jsonFile); }
  void add_atlasFile(flatbuffers::Offset<flatbuffers::String> atlasFile) { fbb_.AddOffset(SpineSkeleton::VT_ATLASFILE, atlasFile); }
  void add_defaultSkin(flatbuffers::Offset<flatbuffers::String> defaultSkin) { fbb_.AddOffset(SpineSkeleton::VT_DEFAULTSKIN, defaultSkin); }
  void add_defaultAnimation(flatbuffers::Offset<flatbuffers::String> defaultAnimation) { fbb_.AddOffset(SpineSkeleton::VT_DEFAULTANIMATION, defaultAnimation); }
  void add_loop(bool loop) { fbb_.AddElement<uint8_t>(SpineSkeleton::VT_LOOP, static_cast<uint8_t>(loop), 0); }
  void add_premultipliedAlpha(bool premultipliedAlpha) { fbb_.AddElement<uint8_t>(SpineSkeleton::VT_PREMULTIPLIEDALPHA, static_cast<uint8_t>(premultipliedAlpha), 0); }
  void add_timeScale(float timeScale) { fbb_.AddElement<float>(SpineSkeleton::VT_TIMESCALE, timeScale, 1.0f); }
  void add_debugSlots(bool debugSlots) { fbb_.AddElement<uint8_t>(SpineSkeleton::VT_DEBUGSLOTS, static_cast<uint8_t>(debugSlots), 0); }
  void add_debugBones(bool debugBones) { fbb_.AddElement<uint8_t>(SpineSkeleton::VT_DEBUGBONES, static_cast<uint8_t>(debugBones), 0); }
  SpineSkeletonBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SpineSkeletonBuilder &operator=(const SpineSkeletonBuilder &);
  flatbuffers::Offset<SpineSkeleton> Finish() {
    auto o = flatbuffers::Offset<SpineSkeleton>(fbb_.EndTable(start_, 10));
    return o;
  }
};

inline flatbuffers::Offset<SpineSkeleton> CreateSpineSkeleton(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> jsonFile = 0,
    flatbuffers::Offset<flatbuffers::String> atlasFile = 0,
    flatbuffers::Offset<flatbuffers::String> defaultSkin = 0,
    flatbuffers::Offset<flatbuffers::String> defaultAnimation = 0,
    bool loop = false,
    bool premultipliedAlpha = false,
    float timeScale = 1.0f,
    bool debugSlots = false,
    bool debugBones = false) {
  SpineSkeletonBuilder builder_(_fbb);
  builder_.add_timeScale(timeScale);
  builder_.add_defaultAnimation(defaultAnimation);
  builder_.add_defaultSkin(defaultSkin);
  builder_.add_atlasFile(atlasFile);
  builder_.add_jsonFile(jsonFile);
  builder_.add_node(node);
  builder_.add_debugBones(debugBones);
  builder_.add_debugSlots(debugSlots);
  builder_.add_premultipliedAlpha(premultipliedAlpha);
  builder_.add_loop(loop);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpineSkeleton> CreateSpineSkeletonDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *jsonFile = nullptr,
    const char *atlasFile = nullptr,
    const char *defaultSkin = nullptr,
    const char *defaultAnimation = nullptr,
    bool loop = false,
    bool premultipliedAlpha = false,
    float timeScale = 1.0f,
    bool debugSlots = false,
    bool debugBones = false) {
  return CreateSpineSkeleton(_fbb, node, jsonFile ? _fbb.CreateString(jsonFile) : 0, atlasFile ? _fbb.CreateString(atlasFile) : 0, defaultSkin ? _fbb.CreateString(defaultSkin) : 0, defaultAnimation ? _fbb.CreateString(defaultAnimation) : 0, loop, premultipliedAlpha, timeScale, debugSlots, debugBones);
}

struct AnimationRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLIPS = 4,
    VT_PLAYONLOAD = 6,
    VT_DEFAULTCLIP = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<AnimationClip>> *clips() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationClip>> *>(VT_CLIPS); }
  bool playOnLoad() const { return GetField<uint8_t>(VT_PLAYONLOAD, 0) != 0; }
  const flatbuffers::String *defaultClip() const { return GetPointer<const flatbuffers::String *>(VT_DEFAULTCLIP); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CLIPS) &&
           verifier.Verify(clips()) &&
           verifier.VerifyVectorOfTables(clips()) &&
           VerifyField<uint8_t>(verifier, VT_PLAYONLOAD) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DEFAULTCLIP) &&
           verifier.Verify(defaultClip()) &&
           verifier.EndTable();
  }
};

struct AnimationRefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_clips(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationClip>>> clips) { fbb_.AddOffset(AnimationRef::VT_CLIPS, clips); }
  void add_playOnLoad(bool playOnLoad) { fbb_.AddElement<uint8_t>(AnimationRef::VT_PLAYONLOAD, static_cast<uint8_t>(playOnLoad), 0); }
  void add_defaultClip(flatbuffers::Offset<flatbuffers::String> defaultClip) { fbb_.AddOffset(AnimationRef::VT_DEFAULTCLIP, defaultClip); }
  AnimationRefBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimationRefBuilder &operator=(const AnimationRefBuilder &);
  flatbuffers::Offset<AnimationRef> Finish() {
    auto o = flatbuffers::Offset<AnimationRef>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<AnimationRef> CreateAnimationRef(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationClip>>> clips = 0,
    bool playOnLoad = false,
    flatbuffers::Offset<flatbuffers::String> defaultClip = 0) {
  AnimationRefBuilder builder_(_fbb);
  builder_.add_defaultClip(defaultClip);
  builder_.add_clips(clips);
  builder_.add_playOnLoad(playOnLoad);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationRef> CreateAnimationRefDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AnimationClip>> *clips = nullptr,
    bool playOnLoad = false,
    const char *defaultClip = nullptr) {
  return CreateAnimationRef(_fbb, clips ? _fbb.CreateVector<flatbuffers::Offset<AnimationClip>>(*clips) : 0, playOnLoad, defaultClip ? _fbb.CreateString(defaultClip) : 0);
}

struct AnimationClip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_DURATION = 6,
    VT_SAMPLE = 8,
    VT_SPEED = 10,
    VT_WRAPMODE = 12,
    VT_CURVEDATA = 14
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  float duration() const { return GetField<float>(VT_DURATION, 0.0f); }
  float sample() const { return GetField<float>(VT_SAMPLE, 0.0f); }
  float speed() const { return GetField<float>(VT_SPEED, 0.0f); }
  AnimWrapMode wrapMode() const { return static_cast<AnimWrapMode>(GetField<int8_t>(VT_WRAPMODE, 0)); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimCurveData>> *curveData() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimCurveData>> *>(VT_CURVEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<float>(verifier, VT_DURATION) &&
           VerifyField<float>(verifier, VT_SAMPLE) &&
           VerifyField<float>(verifier, VT_SPEED) &&
           VerifyField<int8_t>(verifier, VT_WRAPMODE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVEDATA) &&
           verifier.Verify(curveData()) &&
           verifier.VerifyVectorOfTables(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimationClipBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(AnimationClip::VT_NAME, name); }
  void add_duration(float duration) { fbb_.AddElement<float>(AnimationClip::VT_DURATION, duration, 0.0f); }
  void add_sample(float sample) { fbb_.AddElement<float>(AnimationClip::VT_SAMPLE, sample, 0.0f); }
  void add_speed(float speed) { fbb_.AddElement<float>(AnimationClip::VT_SPEED, speed, 0.0f); }
  void add_wrapMode(AnimWrapMode wrapMode) { fbb_.AddElement<int8_t>(AnimationClip::VT_WRAPMODE, static_cast<int8_t>(wrapMode), 0); }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimCurveData>>> curveData) { fbb_.AddOffset(AnimationClip::VT_CURVEDATA, curveData); }
  AnimationClipBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimationClipBuilder &operator=(const AnimationClipBuilder &);
  flatbuffers::Offset<AnimationClip> Finish() {
    auto o = flatbuffers::Offset<AnimationClip>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<AnimationClip> CreateAnimationClip(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    float duration = 0.0f,
    float sample = 0.0f,
    float speed = 0.0f,
    AnimWrapMode wrapMode = AnimWrapMode_Default,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimCurveData>>> curveData = 0) {
  AnimationClipBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_speed(speed);
  builder_.add_sample(sample);
  builder_.add_duration(duration);
  builder_.add_name(name);
  builder_.add_wrapMode(wrapMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationClip> CreateAnimationClipDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    float duration = 0.0f,
    float sample = 0.0f,
    float speed = 0.0f,
    AnimWrapMode wrapMode = AnimWrapMode_Default,
    const std::vector<flatbuffers::Offset<AnimCurveData>> *curveData = nullptr) {
  return CreateAnimationClip(_fbb, name ? _fbb.CreateString(name) : 0, duration, sample, speed, wrapMode, curveData ? _fbb.CreateVector<flatbuffers::Offset<AnimCurveData>>(*curveData) : 0);
}

struct AnimCurveData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PATH = 4,
    VT_PROPS = 6
  };
  const flatbuffers::String *path() const { return GetPointer<const flatbuffers::String *>(VT_PATH); }
  const AnimProps *props() const { return GetPointer<const AnimProps *>(VT_PROPS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PATH) &&
           verifier.Verify(path()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PROPS) &&
           verifier.VerifyTable(props()) &&
           verifier.EndTable();
  }
};

struct AnimCurveDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::String> path) { fbb_.AddOffset(AnimCurveData::VT_PATH, path); }
  void add_props(flatbuffers::Offset<AnimProps> props) { fbb_.AddOffset(AnimCurveData::VT_PROPS, props); }
  AnimCurveDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimCurveDataBuilder &operator=(const AnimCurveDataBuilder &);
  flatbuffers::Offset<AnimCurveData> Finish() {
    auto o = flatbuffers::Offset<AnimCurveData>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimCurveData> CreateAnimCurveData(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    flatbuffers::Offset<AnimProps> props = 0) {
  AnimCurveDataBuilder builder_(_fbb);
  builder_.add_props(props);
  builder_.add_path(path);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimCurveData> CreateAnimCurveDataDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr,
    flatbuffers::Offset<AnimProps> props = 0) {
  return CreateAnimCurveData(_fbb, path ? _fbb.CreateString(path) : 0, props);
}

struct AnimProps FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ROTATION = 4,
    VT_POSITION = 6,
    VT_POSITIONX = 8,
    VT_POSITIONY = 10,
    VT_ANCHORX = 12,
    VT_ANCHORY = 14,
    VT_COLOR = 16,
    VT_OPACITY = 18,
    VT_WIDTH = 20,
    VT_HEIGHT = 22,
    VT_SCALEX = 24,
    VT_SCALEY = 26,
    VT_SKEWX = 28,
    VT_SKEWY = 30
  };
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropRotation>> *rotation() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropRotation>> *>(VT_ROTATION); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropPosition>> *position() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropPosition>> *>(VT_POSITION); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionX>> *positionX() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionX>> *>(VT_POSITIONX); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionY>> *positionY() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionY>> *>(VT_POSITIONY); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorX>> *anchorX() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorX>> *>(VT_ANCHORX); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorY>> *anchorY() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorY>> *>(VT_ANCHORY); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropColor>> *color() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropColor>> *>(VT_COLOR); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropOpacity>> *opacity() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropOpacity>> *>(VT_OPACITY); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropWidth>> *width() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropWidth>> *>(VT_WIDTH); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropHeight>> *height() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropHeight>> *>(VT_HEIGHT); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleX>> *scaleX() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleX>> *>(VT_SCALEX); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleY>> *scaleY() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleY>> *>(VT_SCALEY); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewX>> *skewX() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewX>> *>(VT_SKEWX); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewY>> *skewY() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewY>> *>(VT_SKEWY); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ROTATION) &&
           verifier.Verify(rotation()) &&
           verifier.VerifyVectorOfTables(rotation()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_POSITION) &&
           verifier.Verify(position()) &&
           verifier.VerifyVectorOfTables(position()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_POSITIONX) &&
           verifier.Verify(positionX()) &&
           verifier.VerifyVectorOfTables(positionX()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_POSITIONY) &&
           verifier.Verify(positionY()) &&
           verifier.VerifyVectorOfTables(positionY()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ANCHORX) &&
           verifier.Verify(anchorX()) &&
           verifier.VerifyVectorOfTables(anchorX()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ANCHORY) &&
           verifier.Verify(anchorY()) &&
           verifier.VerifyVectorOfTables(anchorY()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COLOR) &&
           verifier.Verify(color()) &&
           verifier.VerifyVectorOfTables(color()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OPACITY) &&
           verifier.Verify(opacity()) &&
           verifier.VerifyVectorOfTables(opacity()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_WIDTH) &&
           verifier.Verify(width()) &&
           verifier.VerifyVectorOfTables(width()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HEIGHT) &&
           verifier.Verify(height()) &&
           verifier.VerifyVectorOfTables(height()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SCALEX) &&
           verifier.Verify(scaleX()) &&
           verifier.VerifyVectorOfTables(scaleX()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SCALEY) &&
           verifier.Verify(scaleY()) &&
           verifier.VerifyVectorOfTables(scaleY()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SKEWX) &&
           verifier.Verify(skewX()) &&
           verifier.VerifyVectorOfTables(skewX()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SKEWY) &&
           verifier.Verify(skewY()) &&
           verifier.VerifyVectorOfTables(skewY()) &&
           verifier.EndTable();
  }
};

struct AnimPropsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rotation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropRotation>>> rotation) { fbb_.AddOffset(AnimProps::VT_ROTATION, rotation); }
  void add_position(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPosition>>> position) { fbb_.AddOffset(AnimProps::VT_POSITION, position); }
  void add_positionX(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionX>>> positionX) { fbb_.AddOffset(AnimProps::VT_POSITIONX, positionX); }
  void add_positionY(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionY>>> positionY) { fbb_.AddOffset(AnimProps::VT_POSITIONY, positionY); }
  void add_anchorX(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorX>>> anchorX) { fbb_.AddOffset(AnimProps::VT_ANCHORX, anchorX); }
  void add_anchorY(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorY>>> anchorY) { fbb_.AddOffset(AnimProps::VT_ANCHORY, anchorY); }
  void add_color(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropColor>>> color) { fbb_.AddOffset(AnimProps::VT_COLOR, color); }
  void add_opacity(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropOpacity>>> opacity) { fbb_.AddOffset(AnimProps::VT_OPACITY, opacity); }
  void add_width(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropWidth>>> width) { fbb_.AddOffset(AnimProps::VT_WIDTH, width); }
  void add_height(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropHeight>>> height) { fbb_.AddOffset(AnimProps::VT_HEIGHT, height); }
  void add_scaleX(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleX>>> scaleX) { fbb_.AddOffset(AnimProps::VT_SCALEX, scaleX); }
  void add_scaleY(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleY>>> scaleY) { fbb_.AddOffset(AnimProps::VT_SCALEY, scaleY); }
  void add_skewX(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewX>>> skewX) { fbb_.AddOffset(AnimProps::VT_SKEWX, skewX); }
  void add_skewY(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewY>>> skewY) { fbb_.AddOffset(AnimProps::VT_SKEWY, skewY); }
  AnimPropsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropsBuilder &operator=(const AnimPropsBuilder &);
  flatbuffers::Offset<AnimProps> Finish() {
    auto o = flatbuffers::Offset<AnimProps>(fbb_.EndTable(start_, 14));
    return o;
  }
};

inline flatbuffers::Offset<AnimProps> CreateAnimProps(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropRotation>>> rotation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPosition>>> position = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionX>>> positionX = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionY>>> positionY = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorX>>> anchorX = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorY>>> anchorY = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropColor>>> color = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropOpacity>>> opacity = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropWidth>>> width = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropHeight>>> height = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleX>>> scaleX = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleY>>> scaleY = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewX>>> skewX = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewY>>> skewY = 0) {
  AnimPropsBuilder builder_(_fbb);
  builder_.add_skewY(skewY);
  builder_.add_skewX(skewX);
  builder_.add_scaleY(scaleY);
  builder_.add_scaleX(scaleX);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_opacity(opacity);
  builder_.add_color(color);
  builder_.add_anchorY(anchorY);
  builder_.add_anchorX(anchorX);
  builder_.add_positionY(positionY);
  builder_.add_positionX(positionX);
  builder_.add_position(position);
  builder_.add_rotation(rotation);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimProps> CreateAnimPropsDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AnimPropRotation>> *rotation = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropPosition>> *position = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropPositionX>> *positionX = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropPositionY>> *positionY = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropAnchorX>> *anchorX = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropAnchorY>> *anchorY = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropColor>> *color = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropOpacity>> *opacity = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropWidth>> *width = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropHeight>> *height = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropScaleX>> *scaleX = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropScaleY>> *scaleY = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropSkewX>> *skewX = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropSkewY>> *skewY = nullptr) {
  return CreateAnimProps(_fbb, rotation ? _fbb.CreateVector<flatbuffers::Offset<AnimPropRotation>>(*rotation) : 0, position ? _fbb.CreateVector<flatbuffers::Offset<AnimPropPosition>>(*position) : 0, positionX ? _fbb.CreateVector<flatbuffers::Offset<AnimPropPositionX>>(*positionX) : 0, positionY ? _fbb.CreateVector<flatbuffers::Offset<AnimPropPositionY>>(*positionY) : 0, anchorX ? _fbb.CreateVector<flatbuffers::Offset<AnimPropAnchorX>>(*anchorX) : 0, anchorY ? _fbb.CreateVector<flatbuffers::Offset<AnimPropAnchorY>>(*anchorY) : 0, color ? _fbb.CreateVector<flatbuffers::Offset<AnimPropColor>>(*color) : 0, opacity ? _fbb.CreateVector<flatbuffers::Offset<AnimPropOpacity>>(*opacity) : 0, width ? _fbb.CreateVector<flatbuffers::Offset<AnimPropWidth>>(*width) : 0, height ? _fbb.CreateVector<flatbuffers::Offset<AnimPropHeight>>(*height) : 0, scaleX ? _fbb.CreateVector<flatbuffers::Offset<AnimPropScaleX>>(*scaleX) : 0, scaleY ? _fbb.CreateVector<flatbuffers::Offset<AnimPropScaleY>>(*scaleY) : 0, skewX ? _fbb.CreateVector<flatbuffers::Offset<AnimPropSkewX>>(*skewX) : 0, skewY ? _fbb.CreateVector<flatbuffers::Offset<AnimPropSkewY>>(*skewY) : 0);
}

struct AnimEvents FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AnimEventsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  AnimEventsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimEventsBuilder &operator=(const AnimEventsBuilder &);
  flatbuffers::Offset<AnimEvents> Finish() {
    auto o = flatbuffers::Offset<AnimEvents>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<AnimEvents> CreateAnimEvents(flatbuffers::FlatBufferBuilder &_fbb) {
  AnimEventsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AnimPropRotation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct AnimPropRotationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropRotation::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropRotation::VT_VALUE, value, 0.0f); }
  AnimPropRotationBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropRotationBuilder &operator=(const AnimPropRotationBuilder &);
  flatbuffers::Offset<AnimPropRotation> Finish() {
    auto o = flatbuffers::Offset<AnimPropRotation>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropRotation> CreateAnimPropRotation(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f) {
  AnimPropRotationBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

struct AnimPropPosition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  const Vec2 *value() const { return GetStruct<const Vec2 *>(VT_VALUE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<Vec2>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct AnimPropPositionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropPosition::VT_FRAME, frame, 0.0f); }
  void add_value(const Vec2 *value) { fbb_.AddStruct(AnimPropPosition::VT_VALUE, value); }
  AnimPropPositionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropPositionBuilder &operator=(const AnimPropPositionBuilder &);
  flatbuffers::Offset<AnimPropPosition> Finish() {
    auto o = flatbuffers::Offset<AnimPropPosition>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropPosition> CreateAnimPropPosition(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    const Vec2 *value = 0) {
  AnimPropPositionBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

struct AnimPropPositionX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct AnimPropPositionXBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropPositionX::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropPositionX::VT_VALUE, value, 0.0f); }
  AnimPropPositionXBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropPositionXBuilder &operator=(const AnimPropPositionXBuilder &);
  flatbuffers::Offset<AnimPropPositionX> Finish() {
    auto o = flatbuffers::Offset<AnimPropPositionX>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropPositionX> CreateAnimPropPositionX(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f) {
  AnimPropPositionXBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

struct AnimPropPositionY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct AnimPropPositionYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropPositionY::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropPositionY::VT_VALUE, value, 0.0f); }
  AnimPropPositionYBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropPositionYBuilder &operator=(const AnimPropPositionYBuilder &);
  flatbuffers::Offset<AnimPropPositionY> Finish() {
    auto o = flatbuffers::Offset<AnimPropPositionY>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropPositionY> CreateAnimPropPositionY(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f) {
  AnimPropPositionYBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

struct AnimPropScaleX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct AnimPropScaleXBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropScaleX::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropScaleX::VT_VALUE, value, 0.0f); }
  AnimPropScaleXBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropScaleXBuilder &operator=(const AnimPropScaleXBuilder &);
  flatbuffers::Offset<AnimPropScaleX> Finish() {
    auto o = flatbuffers::Offset<AnimPropScaleX>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropScaleX> CreateAnimPropScaleX(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f) {
  AnimPropScaleXBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

struct AnimPropScaleY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct AnimPropScaleYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropScaleY::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropScaleY::VT_VALUE, value, 0.0f); }
  AnimPropScaleYBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropScaleYBuilder &operator=(const AnimPropScaleYBuilder &);
  flatbuffers::Offset<AnimPropScaleY> Finish() {
    auto o = flatbuffers::Offset<AnimPropScaleY>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropScaleY> CreateAnimPropScaleY(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f) {
  AnimPropScaleYBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

struct AnimPropWidth FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct AnimPropWidthBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropWidth::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropWidth::VT_VALUE, value, 0.0f); }
  AnimPropWidthBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropWidthBuilder &operator=(const AnimPropWidthBuilder &);
  flatbuffers::Offset<AnimPropWidth> Finish() {
    auto o = flatbuffers::Offset<AnimPropWidth>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropWidth> CreateAnimPropWidth(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f) {
  AnimPropWidthBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

struct AnimPropHeight FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct AnimPropHeightBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropHeight::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropHeight::VT_VALUE, value, 0.0f); }
  AnimPropHeightBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropHeightBuilder &operator=(const AnimPropHeightBuilder &);
  flatbuffers::Offset<AnimPropHeight> Finish() {
    auto o = flatbuffers::Offset<AnimPropHeight>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropHeight> CreateAnimPropHeight(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f) {
  AnimPropHeightBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

struct AnimPropColor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  const ColorRGBA *value() const { return GetStruct<const ColorRGBA *>(VT_VALUE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<ColorRGBA>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct AnimPropColorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropColor::VT_FRAME, frame, 0.0f); }
  void add_value(const ColorRGBA *value) { fbb_.AddStruct(AnimPropColor::VT_VALUE, value); }
  AnimPropColorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropColorBuilder &operator=(const AnimPropColorBuilder &);
  flatbuffers::Offset<AnimPropColor> Finish() {
    auto o = flatbuffers::Offset<AnimPropColor>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropColor> CreateAnimPropColor(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    const ColorRGBA *value = 0) {
  AnimPropColorBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

struct AnimPropOpacity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct AnimPropOpacityBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropOpacity::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropOpacity::VT_VALUE, value, 0.0f); }
  AnimPropOpacityBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropOpacityBuilder &operator=(const AnimPropOpacityBuilder &);
  flatbuffers::Offset<AnimPropOpacity> Finish() {
    auto o = flatbuffers::Offset<AnimPropOpacity>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropOpacity> CreateAnimPropOpacity(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f) {
  AnimPropOpacityBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

struct AnimPropAnchorX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct AnimPropAnchorXBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropAnchorX::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropAnchorX::VT_VALUE, value, 0.0f); }
  AnimPropAnchorXBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropAnchorXBuilder &operator=(const AnimPropAnchorXBuilder &);
  flatbuffers::Offset<AnimPropAnchorX> Finish() {
    auto o = flatbuffers::Offset<AnimPropAnchorX>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropAnchorX> CreateAnimPropAnchorX(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f) {
  AnimPropAnchorXBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

struct AnimPropAnchorY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct AnimPropAnchorYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropAnchorY::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropAnchorY::VT_VALUE, value, 0.0f); }
  AnimPropAnchorYBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropAnchorYBuilder &operator=(const AnimPropAnchorYBuilder &);
  flatbuffers::Offset<AnimPropAnchorY> Finish() {
    auto o = flatbuffers::Offset<AnimPropAnchorY>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropAnchorY> CreateAnimPropAnchorY(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f) {
  AnimPropAnchorYBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

struct AnimPropSkewX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct AnimPropSkewXBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropSkewX::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropSkewX::VT_VALUE, value, 0.0f); }
  AnimPropSkewXBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropSkewXBuilder &operator=(const AnimPropSkewXBuilder &);
  flatbuffers::Offset<AnimPropSkewX> Finish() {
    auto o = flatbuffers::Offset<AnimPropSkewX>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropSkewX> CreateAnimPropSkewX(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f) {
  AnimPropSkewXBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

struct AnimPropSkewY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct AnimPropSkewYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropSkewY::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropSkewY::VT_VALUE, value, 0.0f); }
  AnimPropSkewYBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropSkewYBuilder &operator=(const AnimPropSkewYBuilder &);
  flatbuffers::Offset<AnimPropSkewY> Finish() {
    auto o = flatbuffers::Offset<AnimPropSkewY>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropSkewY> CreateAnimPropSkewY(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f) {
  AnimPropSkewYBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline bool VerifyAnyNode(flatbuffers::Verifier &verifier, const void *union_obj, AnyNode type) {
  switch (type) {
    case AnyNode_NONE: return true;
    case AnyNode_Scene: return verifier.VerifyTable(reinterpret_cast<const Scene *>(union_obj));
    case AnyNode_Sprite: return verifier.VerifyTable(reinterpret_cast<const Sprite *>(union_obj));
    case AnyNode_Label: return verifier.VerifyTable(reinterpret_cast<const Label *>(union_obj));
    case AnyNode_Particle: return verifier.VerifyTable(reinterpret_cast<const Particle *>(union_obj));
    case AnyNode_TileMap: return verifier.VerifyTable(reinterpret_cast<const TileMap *>(union_obj));
    case AnyNode_Node: return verifier.VerifyTable(reinterpret_cast<const Node *>(union_obj));
    case AnyNode_Button: return verifier.VerifyTable(reinterpret_cast<const Button *>(union_obj));
    case AnyNode_ProgressBar: return verifier.VerifyTable(reinterpret_cast<const ProgressBar *>(union_obj));
    case AnyNode_ScrollView: return verifier.VerifyTable(reinterpret_cast<const ScrollView *>(union_obj));
    case AnyNode_CreatorScene: return verifier.VerifyTable(reinterpret_cast<const CreatorScene *>(union_obj));
    case AnyNode_EditBox: return verifier.VerifyTable(reinterpret_cast<const EditBox *>(union_obj));
    case AnyNode_RichText: return verifier.VerifyTable(reinterpret_cast<const RichText *>(union_obj));
    case AnyNode_SpineSkeleton: return verifier.VerifyTable(reinterpret_cast<const SpineSkeleton *>(union_obj));
    default: return false;
  }
}

inline const creator::buffers::SceneGraph *GetSceneGraph(const void *buf) {
  return flatbuffers::GetRoot<creator::buffers::SceneGraph>(buf);
}

inline const char *SceneGraphIdentifier() {
  return "CCRE";
}

inline bool SceneGraphBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(buf, SceneGraphIdentifier());
}

inline bool VerifySceneGraphBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<creator::buffers::SceneGraph>(SceneGraphIdentifier());
}

inline const char *SceneGraphExtension() { return "ccreator"; }

inline void FinishSceneGraphBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<creator::buffers::SceneGraph> root) {
  fbb.Finish(root, SceneGraphIdentifier());
}

}  // namespace buffers
}  // namespace creator

#endif  // FLATBUFFERS_GENERATED_CREATORREADER_CREATOR_BUFFERS_H_
